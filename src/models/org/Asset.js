
const FS = require('fs');
const Mongoose = require('mongoose');
const Schema = Mongoose.Schema;
const ObjectId = Schema.ObjectId;
const RandomString = require("randomstring");
const Async = require('async');
const ToHex = require('to-hex');
const QRCode = require('qrcode');
const EJS = require('ejs');
const Moment = require('moment');
const QrCode = require('qrcode-reader');

const Utils = require('../utils');
const K = require("../../K");
const {func} = require("joi");
const Validator = require("validator");
const Lodash = require("lodash");
const AddressSchema = Utils.AddressSchema;
const ContactSchema = Utils.ContactSchema;
const CollSchemaShort= Utils.CollSchemaShort;
const ES6Template = require('es6-template-string');
const html_to_pdf = require("html-pdf-node");
const fs = require("fs");
const Jimp = require("jimp");
const path = require("path");
const otpGenerator = require("otp-generator");
const main = require("merge");
const {send} = require("@sendgrid/mail");
const MaskEmailsPhones = require("mask-email-phone");
const {toDate} = require("../../lib/DateUtils");

const COLLECTION_NAME = 'asset';

const ASSET_STATUS = {
    DRAFT           : '01_draft',  // QR code generated, yet to be tagged to an asset, customer (internal)
    BOOKED          : 'booked',
    ACCEPTED        : 'accepted', //(On issuance of Payment receipt)
    READY_FOR_DELIVERY: 'readyForDelivery',
    DELIVERED       : 'delivered',
    IN_STOCK        : '02_in_stock',   // Ready to be given for rental/sold
    IN_TRANSIT      : '03_in_transit', // Pending installation or in transport
    IN_USE          : '04_in_use',     // Customer is using the asset
    IN_MAINTENANCE  : '05_in_maintenance',
    RETIRED         : '06_retired',
    MISSING         : '07_missing',
    CANCELLED       : 'cancelled'   //(Upon order cancellation)
};

const EVENT = {
    CREATE: {
        name: 'Created',
        code: 0x001,
    },
    UPDATE_BASIC_DETAILS: {
        name: 'Updated Basic Details',
        code: 0x002
    },
    UPDATE_CONTACT_DETAILS: {
        name: 'Updated Contact Details',
        code: 0x03
    },
    UPDATE_ADDRESS: {
        name: 'Updated Address',
        code: 0x03
    },
    UPDATE_CUSTOMER: {
        name: 'Updated Customer',
        code: 0x005
    },
    UPDATE_TECHNICIAN: {
        name: 'Updated Technician',
        code: 0x006
    },
    UPDATE_ACCESSORIES: {
        name: 'Updated Installed Accessories',
        code: 0x007
    },
    UPDATE_PM_SCHEDULE: {
        name: 'Updated PM Schedule',
        code: 0x008
    },
    METER_READING: {
        name: 'Captured Meter Reading',
        code: 0x009
    },
    ATTACH_CONTRACT: {
        name: 'Added Contract',
        code: 0x00A
    },
    DETACH_CONTRACT: {
        name: 'Removed Contract',
        code: 0x00B
    },
    UPDATE_ORG_UNIT: {
        name: 'Org Unit tagging updated',
        code: 0x00C
    },
    UPDATE_SITE: {
        name: 'Site tagging updated',
        code: 0x00D
    },
    UPDATE_STATUS: {
        name: 'Status Updated',
        code: 0x00E
    },
    UPDATE_BOOKING_STATUS: {
        name: 'Booking Status Updated',
        code: 0x010
    },
    UPDATE_PRIMARY_DETAILS: {
        name: 'Primary Details Updated',
        code: 0x010
    },
    COMMUNICATION_SENT: {
        name: 'Communication Sent to Customer',
        code: 0x011
    }
};

module.exports = function(app, doneCb) {

    const Db = app.locals.Db;
    const Settings = app.locals.Settings;
    const CollectionSettings= Settings.asset;
    const OWNERSHIP_TYPES = Utils.getIds(Settings.asset.ownershipTypes);
    const DEFAULT_OWNERSHIP_TYPE = app.locals.Settings.asset.defaultOwnershipType;
    const SEQ_CODE_PREFIX= CollectionSettings.seqCodePrefix||'ASSET';
    const SEQ_ID_PADDING= CollectionSettings.numDigits|| 4;

    const MeterReadingSchema = {
        asOn        : {
            type    : Date,
            default : Date.now
        },
        refTicket   : {
            _id     : ObjectId
        },
        readings    : {}    //key value pairs of => meterTypeId: reading
    };

    let isSecondaryCodeUnique= true;
    if (Settings.asset.fields.secondaryCode && (Settings.asset.fields.secondaryCode.unique === false)){
        isSecondaryCodeUnique= false;
    }
    const opts = { toJSON: { virtuals: true }, toObject: {virtuals: true} };

    const schemaObj = new Schema({
        name        : { //Concat(product,model) -- derived field
            type    : String,
            trim    : true
        },
        code        : { //ASSET000001 -- auto generated
            type    : String,
            trim    : true,
            unique  : true,
            uppercase: true
        },
        seqId       : { //autogenerated
            type    : Number,
            unique  : true
        },
        /**
         * @desc - This field is used to store user inputted unique code while
         * loading past data from the user
         */
        secondaryCode: {
            type    : String,
            trim    : true,
            index   : {
                unique  : isSecondaryCodeUnique,
                sparse  : true
            }
        },
        /**
         * @desc - Serial number given by OEM/Manufacturer
         */
        serialNumber: {
            type    : String,
            trim    : true,
            uppercase: true,
            index   : {
                unique  : Settings.asset.fields?.serialNumber?.isUnique||false,
                sparse  : true
            }
        },
        secondarySerialNumber: {
            type    : String,
            trim    : true,
            uppercase: true,
            index   : {
                unique  : true,
                sparse  : true
            }
        },
        extraCode1: {
            type    : String,
            trim    : true,
            uppercase: true,
            index: true
        },
        extraCode2: {
            type    : String,
            trim    : true,
            uppercase: true,
            index: true
        },
        isUnderWarranty: {type: Boolean},
        warrantyStartDate: {type: Date},
        warrantyEndDate: {type: Date},
        /**
         * @desc - This is part of the qr code unique id
         */
        publicCode      : {  //{orgcode}-{asset seqid}-{random string}
            type        : String,
            trim    : true,
            unique      : true
        },
        // publicUrl       : {  //need to remove from db as well, for earlier ones this data is populated
        //     type        : String,
        // },

        sku         : {},
        extSku      : {},   //All the information related to sku, which is not part of master
        model       : {
            ...CollSchemaShort,
            product : {
                ...CollSchemaShort,
                manufacturer: {type: String}
            },
            meterTypes: [{}]
        },
        ownershipType : {
            type    : String,
            default : DEFAULT_OWNERSHIP_TYPE,
            enum    : OWNERSHIP_TYPES
        },
        purchaseDate: {
            type    : Date
        },
        warranty    : {

        },

        contract    : {
            ...CollSchemaShort,
            startDate: {type: Date},
            endDate  : {type: Date},
            status   : {type: String},
            //only for reportings sake, need to populate through script if want to use
            referenceNumber: {type: String},
            cType: {type: String}
        },

        customer    : {...CollSchemaShort},
        site        : { ...CollSchemaShort },

        isContactSameAsPrimaryContact: {type: Boolean},
        contact     : {...ContactSchema},

        locatedAt   : {type : String},
        isAddrSameAsCustomerAddr: {type: Boolean, default:true},
        address     : {...AddressSchema},

        technician  : {...CollSchemaShort},
        orgUnit     : {...CollSchemaShort, custom:{}},

        isInstalled : {type: Boolean},
        installedOn : {type: Date},
        accessoriesInstalled: [{
            _id     : ObjectId,
            name    : {type: String},
            serialNumber: {type: String},
            installedOn: {type: Date}
        }],
        status      : {
            type    : String,
            enum    : Object.values(ASSET_STATUS),
            default : ASSET_STATUS.IN_STOCK,
            lowercase: true,
            required: true
        },

        supplier: {type: String},
        purchaseCost: {type: Number},
        criticalityRating: {
            type: String,
            uppercase: true,
            enum: ['A', 'B','C', '']
        },

        isCritical: {type: Boolean},

        lastEvent   : Schema.Types.Mixed,

        latestMeterReadings : {
            readings: {},   //
            ticket: {...CollSchemaShort},
            asOn: Date
        },
        pastMeterReadings: [
            {
                readings: {},   //
                ticket: {...CollSchemaShort},
                asOn: Date
            }
        ],
        serviceProvidedBy: {
            type: String
        },
        remarks: {
            type: String
        },
        latestLoc   : {
            lat         : {type: Number},
            lng         : {type: Number},
            receivedOn  : {type: Date},
        },
        // searchText: {
        //     type: String
        // }
        latestTicketClosed: {
            doneAt: {type: Date},
            refTicket: {...CollSchemaShort}
        },
        custom: {
        },

        lastStatusUpdatedOn: {
            type: Date
        },
        // Trigger status updates to customer details
        isLatestStatusUpdateTriggered: {
            type: Boolean
        },
        lastStatusUpdateTriggeredOn: {
            type: Date
        },
        lastStatusUpdateTriggerStatus: {  //based on API
            type: String,
            enum: ['success', 'partialSuccess', 'failure', 'noChannels']
        },
        lastStatusUpdateTriggerChannels:[String],
        lastStatusUpdateTriggerData: {

        },
        isWelcomeTriggered: {
            type: Boolean,
            default: false
        },
        task: {},
        isDeleted: {type: Boolean}
    }, opts);

    const SAMPLE_CUSTOM_TKM= {
        "salesOfficer" : "",
        "tentativeDeliveryQuoted" : "July 2023",
        "bookingDate": "",
        "bookingAmendedOn": "",

        "initialBookingSequenceNumber" : "127",
        "minWaitingPeriodInWeeksQuoted" : 18,
        "maxWaitingPeriodInWeeksQuoted" : 20,
        "waitingPeriodInWeeksQuoted" : "18 - 20 Weeks",

        "currentBookingSequenceNumber" : 122,
        "currentMinWaitingPeriodInWeeks" : 5,
        "currentMaxWaitingPeriodInWeeks" : 6,
        "currentWaitingPeriodInWeeks" : "5 - 6 Weeks",  //Next Update available at xxxx

        "prevBookingSequenceNumber" : 122,
        "prevMinWaitingPeriodInWeeks" : 5,
        "prevMaxWaitingPeriodInWeeks" : 6,
        "prevWaitingPeriodInWeeks" : "5 - 6 Weeks"

    };

    schemaObj.index({'customer._id': 1, isDeleted:1});
    schemaObj.index({'status': 1, 'orgUnit._id':1, isDeleted:1});
    schemaObj.index({'status': 1, 'orgUnit._id':1, isLatestStatusUpdateTriggered: 1, isDeleted:1});
    schemaObj.index({'status': 1, 'orgUnit._id':1, lastStatusUpdateTriggeredOn: -1, isDeleted:1});


    const formatQuery = function (query, cb) {
        let searchConditions;
        if (CollectionSettings.hideDrafts){
            if (!query.status){
                query.status= 'nonDraft';
            }
        }
        if (query.q) {
            let searchStr= query.q;
            let conditions= {};
            let regexp= {$regex: new RegExp('.*'+searchStr+'.*', 'i')};
            if (Validator.isMobilePhone(searchStr)){
                conditions= {
                    '$or':[
                        {'contact.phoneNumber': searchStr },
                        {'contact.altPhoneNumber': searchStr}
                    ]
                };
            }
            else {
                conditions={
                    '$or': [
                        {'name': regexp},
                        {'customer.name': regexp},
                    ]
                }
            }
            conditions['$or'].push({'code': regexp});
            conditions['$or'].push({'serialNumber': regexp});
            conditions['$or'].push({'secondaryCode': regexp});
            conditions['$or'].push({'locatedAt': regexp});
            conditions['$or'].push({'address.city': regexp});
            conditions['$or'].push({'address.state': regexp});
            conditions['$or'].push({'address.addrLine1': regexp});
            conditions['$or'].push({'address.addrLine2': regexp});
            if (app.locals.Settings.asset.fields.secondarySerialNumber){
                conditions['$or'].push({'secondarySerialNumber': searchStr});
            }
            if (app.locals.Settings.asset.fields.extraCode1){
                conditions['$or'].push({'extraCode1': searchStr});
            }
            delete query.q;
            searchConditions = {...conditions};    //While searching other filters are purposefully ignored
        }
        if (query.serial){  //special search includes exact match
            let searchStr= query.serial.toUpperCase();
            let conditions= {'$or':[]};
            conditions['$or'].push({'code': searchStr});
            conditions['$or'].push({'serialNumber': searchStr});
            conditions['$or'].push({'secondaryCode': searchStr});
            if (app.locals.Settings.asset.fields.secondarySerialNumber){
                conditions['$or'].push({'secondarySerialNumber': searchStr});
            }
            if (app.locals.Settings.asset.fields.extraCode1){
                conditions['$or'].push({'extraCode1': searchStr});
            }
            delete query.serial;
            searchConditions = {...conditions};    //While searching other filters are purposefully ignored
        }
        if (query.customerId){
            if (query.customerId === 'none'){
                query['customer._id']= {$exists:false};
            }
            else {
                query['customer._id']= Mongoose.Types.ObjectId(query.customerId);
            }
            delete query.customerId;
        }
        if (query.siteId){
            if (query.siteId === 'none'){
                query['site._id']= {$exists:false};
            }
            else {
                query['site._id']= Mongoose.Types.ObjectId(query.siteId);
            }
            delete query.siteId;
        }
        if (query.technicianId){
            if (query.technicianId === 'none'){
                query['technician._id']= {$exists:false};
            }
            else {
                query['technician._id']= Mongoose.Types.ObjectId(query.technicianId);
            }
            delete query.technicianId;
        }
        if(query.productId) {
            query['model.product._id']= Mongoose.Types.ObjectId(query.productId);
            delete query.productId;
        }
        if (query.modelId){
            query['model._id']= Mongoose.Types.ObjectId(query.modelId);
            delete query.modelId;
        }
        if (query.contractStatus){
            if (query.contractStatus === 'inactive'){
                query['contract._id']= {$exists: false};
            }
            query.status = {$ne:'01_draft'};
            delete query.contractStatus;
        }
        if (query.contractId) {
            query['contract._id']= Mongoose.Types.ObjectId(query.contractId);
            delete query.contractId;
        }
        if (query.orgUnitId) {
            let orgUnitId= Mongoose.Types.ObjectId(query.orgUnitId);
            if (query['orgUnit._id']){
                query['$and']= [
                    {'orgUnit._id': query['orgUnit._id']},
                    {'orgUnit._id': orgUnitId}
                ]
                delete query['orgUnit._id'];
            }
            else {
                query['orgUnit._id']= orgUnitId;
            }
            delete query.orgUnitId;
        }
        if (query.excludeIds) {
            query._id= {$nin: Lodash.map(query.excludeIds, (id)=>{return Mongoose.Types.ObjectId(id)})};
            delete query.excludeIds;
        }
        if (query.excludeCustomerId){
            query['customer._id']= {$ne: Mongoose.Types.ObjectId(query.excludeCustomerId)};
            delete query.excludeCustomerId;
        }
        let ids= query.id || query.assetId;
        if (ids){
            if (Array.isArray(ids)){
                query._id= {$in: Lodash.map(ids, (id)=>{return Mongoose.Types.ObjectId(id)})};
            }
            else {
                query._id = Mongoose.Types.ObjectId(ids);
            }
            delete query.id;
            delete query.assetId;
        }
        if (query.code){
            let seqId= parseInt(query.code,16);
            query.seqId= seqId;
            delete query.code;
        }

        if (['nonDraft','underContract', 'noContract','underWarranty'].indexOf(query.status) !== -1 ){
            switch(query.status){
                case 'nonDraft':
                    query.status= {$ne: '01_draft'};
                    break;
                case 'underWarranty':
                    query.contract= {$exists: true};
                    query['contract.cType']= 'warranty';
                    break;
                case 'underContract':
                    query['contract.cType']= {$ne:'warranty'};
                    query.contract= {$exists: true};
                    break;
                case 'noContract':
                    query['contract.cType']= {$ne: 'warranty'};
                    query.contract= {$exists: false};
                    break;
            }
            query.status= {$ne: '01_draft'};
        }
        query.isDeleted= {$ne: true};
        if (searchConditions){
            query= {...query, ...searchConditions};
        }
        if (query.includeContractId){
            let orCond= {
                'contract._id': Mongoose.Types.ObjectId(query.includeContractId)
            };
            delete query.includeContractId;
            let queryCopy= {...query};
            query= {$or: [orCond, queryCopy]}
        }
        if (query.updatesTrigger){
            if (query.updatesTrigger === 'yet2Trigger'){
                query.isLatestStatusUpdateTriggered= {$ne:true};
            }
            else if (query.updatesTrigger === 'alreadyTriggered'){
                query.isLatestStatusUpdateTriggered= true;
            }
            delete query.updatesTrigger;
        }
        return cb(undefined, query);
    };

    schemaObj.pre('find', function(next) {
        formatQuery(this.getQuery(), (err, query)=>{
            this.setQuery(query);
            next();
        });
    });

    schemaObj.pre('count', function(next) {
        formatQuery(this.getQuery(), (err, query)=>{
            this.setQuery(query);
            next();
        });
    });

    schemaObj.pre('countDocuments', function(next) {
        formatQuery(this.getQuery(), (err, query)=>{
            this.setQuery(query);
            next();
        });
    });

    schemaObj.pre('save', function (next) {
        /*
        let searchText= '';
        let searchFieldsValues= [
            this.contact?.phoneNumber,
            this.contact?.altPhoneNumber,
            this.name,
            this.customer?.name,
            this.code,
            this.serialNumber,
            this.secondaryCode,
            this.locatedAt,
            this.address?.addrLine1,
            this.address?.addrLine2,
            this.address?.landmark,
            this.address?.area,
            this.address?.city,
            this.address?.state,
            this.address?.pinCode
        ];

        if (app.locals.Settings.asset.fields.secondarySerialNumber){
            searchFieldsValues.push('secondarySerialNumber');
        }
        if (app.locals.Settings.asset.fields.extraCode1){
            searchFieldsValues.push('extraCode1');
        }
        searchFieldsValues.forEach((value)=>{
            if (value){
                searchText += value+ ' ';
            }
        });
        this.searchText= searchText; */

        const ProductModel = app.locals.models.ProductModel;
        const Site = app.locals.models.Site;
        if (this.warrantyEndDate){
            this.isUnderWarranty= (this.warrantyEndDate.valueOf() >= new Date().valueOf())? false:true;
        }
        if (Settings.asset.autoAssignStatus){
            if ((this.customer?._id) ||(this.site?._id)) {
                this.status = ASSET_STATUS.IN_USE;
            } else if ((this.serialNumber || this.secondaryCode) && !this.remarks) {
                this.status = ASSET_STATUS.IN_STOCK;
            }
            else {
                //draft
            }
        }

        const setCustomerSite= (next2)=>{
            if (!Settings.site.autoCreateFromCustomer){
                return next2();
            }
            if (!this.customer?._id) {
                return next2();
            }
            Site.findOne({'customer._id': this.customer._id}, (err, site)=> {
                if (err) {
                    return next2(err);
                }
                if (!site) {
                    console.log('could not find site corresponding to customer', this.customer.code);
                    return next2();
                }
                this.site= site.getShortForm();
                this.markModified('site');
                return next2();
            });
        };

        const setProductModelInfo= (next2)=>{
            if (!this.model && !this.model._id) {
                return next2();
            }
            ProductModel.findById(this.model._id, (err, productModel)=>{
                if (err){
                    return next2(err);
                }
                if (!productModel){
                    return next2();
                }
                this.model= productModel.getShortForm();
                this.markModified('model');
                if (Settings.asset.nameTemplate){
                    this.name= ES6Template(Settings.asset.nameTemplate, {...this.model});
                    return next2();
                }
                if (this.model.product && this.model.product.name) {
                    this.name = this.model.product.name + '/'+this.model.name ;
                    if (productModel.category?.name){
                        this.name= productModel.category.name +'/'+this.name;
                    }
                }
                else if(this.model) {
                    this.name= this.model.name;
                }
                return next2();
                let qrCodeFile= app.locals.dirs.qrcodes+'/'+this.seqId+'.png'
                const Jimp = require("jimp");
                const fs= require('fs');
                let buffer = fs.readFileSync(qrCodeFile);
                console.log('>>>>>>Checking ', this.seqId, qrCodeFile);
                Jimp.read(buffer, (err, image) =>{
                    if (err) {
                        console.error(err);
                        return next2();
                    }
                    let qr = new QrCode();
                    qr.callback = (err, value) =>{
                        if (err) {
                            console.error(err);
                            return next2();
                        }
                        let qrUrlParts = value.result.split('/');
                        let qrPublicCode= qrUrlParts[qrUrlParts.length-1];
                        if ( qrPublicCode !==this.publicCode){
                            console.log(this.seqId, 'not matching!!', this.publicCode, qrPublicCode);
                        }
                        else {
                            console.log(this.seqId, '++++Matching!!', this.publicCode, qrPublicCode);

                        }
                        // console.log(value);
                        return next2();
                    };
                    qr.decode(image.bitmap);
                });
            });
        }

        const setSKUInfo = (next2) =>{
            if (!this.sku ||!this.sku._id){
                return next2();
            }
            const SKUModel= app.locals.models.SKU;
            SKUModel.findById(this.sku._id, (err, sku)=>{
                if (err){
                    return next(err);
                }
                if (!sku){
                    console.log('sku mapped in asset not found!', this.sku._id);
                    return next();
                }
                if (!CollectionSettings.isCustomName){
                    this.name= sku.name;
                }
                let skuObj= sku.toObject();
                this.sku= {
                    _id: sku._id,
                    name: sku.name,
                    model: sku.model,
                    variant: sku.variant,
                    attrs: {...skuObj.attrs}
                };
                this.markModified('sku');
                return next2();
            });
        };

        if (!this.isNew) {
            Async.series([setSKUInfo, setProductModelInfo, setCustomerSite], next);
            return;
        }

        //Generate qr code image and save
        Counter.getNextSequence(COLLECTION_NAME, (err, {code, seqId})=>{
            if (err){
                console.log(err);
                return next('error while getNextSequence!');
            }
            this.code= code;
            this.seqId= seqId;
            const qrcodesOutDir = app.locals.dirs.qrcodes;
            const orgCode = app.locals.Settings.code;
            const orgSeqId = app.locals.id;

            let baseUrl;
            let publicCode;
            let qrCodeFileName;
            if (!Settings.asset.publicUrlVersion){
                baseUrl= `${app.locals.credentials.baseUrl}app/open/org`;
                let randomId = RandomString.generate({length:8, charset: 'alphanumeric'});
                let assetSeqIdHex = ToHex(seqId, { size: 8 });
                publicCode = `${orgCode}-${assetSeqIdHex}-${randomId}`.toLowerCase();
                qrCodeFileName= seqId;
            }
            else {  //V2
                baseUrl = `${app.locals.credentials.baseUrl}appv2/open/org`;
                publicCode = `${orgCode}-${this.code}-${this._id}`.toLowerCase();
                const paddedSeqId= this.code.replace(SEQ_CODE_PREFIX, '');
                qrCodeFileName= paddedSeqId;
            }
            let url = `${baseUrl}/${orgSeqId}/asset/${publicCode}`;

            this.publicCode= publicCode;
            this.publicUrl= url;
            this.name = 'Draft Asset';
            this.status= ASSET_STATUS.DRAFT;
            this.ownershipType= app.locals.Settings.asset.defaultOwnershipType;
            let options = {
                type: 'image/png',
                errorCorrectionLevel: 'H',
                width: 300
            };
            QRCode.toFile(
                    qrcodesOutDir+'/'+qrCodeFileName+'.png',
                    url,
                    options,
                    (err)=>{
                        if (err){
                            return next(err);
                        }
                        return next();
                    }
                );
        });
    });

    schemaObj.methods.regenerateQRCode= function (next){
        const qrcodesOutDir = app.locals.dirs.qrcodes;
        const orgCode = app.locals.Settings.code;
        const orgSeqId = app.locals.id;

        let baseUrl;
        let publicCode;
        let qrCodeFileName;
            baseUrl = `${app.locals.credentials.baseUrl}appv2/open/org`;
            publicCode = `${orgCode}-${this.code}-${this._id}`.toLowerCase();
            const paddedSeqId= this.code.replace(SEQ_CODE_PREFIX, '');
            qrCodeFileName= paddedSeqId;
        let url = `${baseUrl}/${orgSeqId}/asset/${publicCode}`;

        this.publicCode= publicCode;
        this.publicUrl= url;
        let options = {
            type: 'image/png',
            errorCorrectionLevel: 'H',
            width: 300
        };
        QRCode.toFile(
            qrcodesOutDir+'/'+qrCodeFileName+'.png',
            url,
            options,
            (err)=>{
                if (err){
                    return next(err);
                }
                this.save(next);
            }
        );
    }

    schemaObj.post('save', function(doc, next) {
        const Customer = app.locals.models.Customer;
        const Asset= app.locals.models.Asset;
        const Ticket = app.locals.models.Ticket;
        const Contract= app.locals.models.Contract

        if (!Settings.asset.synchronousPostSave){
            next();
        }

        const updateCustomerAssetCount= (next2) =>{
            if(!doc.customer || !doc.customer._id){
                return next2();
            }
            Customer.findById(doc.customer._id, (err, customer) => {
                if (err){
                    return next2(err);
                }
                if (!customer) {
                    return next2({message:`Customer ${doc.customer._id} not found  for asset ${ doc._id}!`});
                }
                Asset.count({'customer._id': customer._id}, (err, count)=>{
                    if (err){
                        return next2(err);
                    }
                    customer.numAssets = count;
                    customer.save((err)=>{
                        if (err){
                            console.log('customer save error:', err);
                        }
                        return next2(err);
                    });
                });
            });
        };

        const syncReplicatedCollections= (next2) =>{
            if (Settings.asset.dontSyncReplicatedCollections){
                return next2();
            }
            const doSync = (Model, next3) => {
                Model.sync(COLLECTION_NAME, this, next3);
            };
            let depModels= [Ticket];
            if (Settings.contract.isEnabled){
                depModels.push(Contract);
            }
            Async.eachSeries(depModels, doSync, (err)=> {
                next2(err);
            });
        };

        Async.series([updateCustomerAssetCount, syncReplicatedCollections], (err)=> {
            if (Settings.asset.synchronousPostSave) {
                return next(err);
            }
        });
    });

    schemaObj.methods.sendStatusUpdate2Customer= function (by, data, cb) {
        let doc= this;
        if (!Settings.asset.sendStatusUpdates2Customer){
            return cb();
        }
        if (['accepted', 'booked'].indexOf(doc.status) === -1){
            console.log('SKIPPING ignorable statuses when sending communication: ', doc.status);
            return cb();
        }
        const mainApp = app.locals.mainApp;
        const emailService = mainApp.locals.services.Email;
        const is2TriggerWelcome= data.triggerWelcome;//||!doc.isWelcomeTriggered;

        const from= {
            email: 'booking_update@qristix.com',
            name: ''
        };

        let userEmail= '';
        let userMobile= '';
        let userName= this.name||this.firstName;
        let baseUrl= app.locals.credentials.baseUrl;
        let appBaseUrl=`${app.locals.credentials.baseUrl}appv2`;
        let customer, sku;
        let orgUnit, parentOrgUnit;
        let triggerData= {
            email: {},
            sms: {}
        };

        const loadCustomer= (next)=>{
            if (!doc.customer?._id){
                return next();
            }
            const Customer= app.locals.models.Customer;
            Customer.findById(doc.customer._id, (err, record)=>{
                if (err){
                    return next(err);
                }
                customer= record;
                userEmail= customer.contact?.email||'';
                userName= customer.name||customer.firstName;
                if (!Validator.isEmail(userEmail)){
                    userEmail= '';
                }
                userMobile= customer.contact?.phoneNumber||'';
                if (!Validator.isMobilePhone(userMobile)){
                    userMobile= '';
                }
                return next();
            });
        };

        const loadSKU= (next)=>{
            if (!doc.sku?._id){
                return next();
            }
            const SKU= app.locals.models.SKU;
            SKU.findById(doc.sku._id, (err, record)=>{
                if (err){
                    return next(err);
                }
                sku= record;
                return next();
            });
        };

        const loadOrgUnitInfo= (next) =>{
            if (!doc.orgUnit?._id){
                return next();
            }
            const OrgUnit= app.locals.models.OrgUnit;
            OrgUnit.findById(doc.orgUnit?._id, (err, record)=>{
                if (err){
                    return next(err);
                }
                if (!record){
                    return next('orgunit not found!');
                }
                orgUnit= record;
                from.name= orgUnit.name;
                if (!record.parent?._id){
                    return next('parent OrgUnit not found!');
                }
                OrgUnit.findById(record.parent._id, (err, record)=>{
                    if (err){
                        return next(err);
                    }
                    if (!record){
                        return next('parent OrgUnit record not found!');
                    }
                    parentOrgUnit= record;
                    return next();
                });
            });
        };

        const sendStatusUpdateEmail= (next)=>{
            if(!userEmail){
                return next();
            }
            let emailTemplateName;
            let subject;
            if (is2TriggerWelcome){
                emailTemplateName= 'thank-you-for-booking';
                subject='Booking Confirmation for your Toyota';
            }
            else {
                if (doc.status === 'delivered'){
                    //TODO: need to implement template
                    return  next();
                }
                else {
                    emailTemplateName= 'booking-status-update';
                    subject= 'Update on your booking for Toyota';
                }
            }
            const emailAssetsBaseUrl= `${app.locals.credentials.baseUrl}/images/email-assets/${emailTemplateName}`;
            const emailTemplatePath= path.join('./tpls/html', emailTemplateName+'.ejs');

            let elapsedWeeks= Moment().diff(doc.installedOn, 'week');
            let minWaitingWeeks= doc.custom.minWaitingPeriodInWeeksQuoted - elapsedWeeks;
            if (minWaitingWeeks<0){
                minWaitingWeeks= 0;
            }
            let maxWaitingWeeks= doc.custom.maxWaitingPeriodInWeeksQuoted - elapsedWeeks;
            if (maxWaitingWeeks <0){
                maxWaitingWeeks= 0;
            }

            let data= {
                userName,
                emailAssetsBaseUrl,
                asset: doc,
                customer,
                sku,
                bookingDate: Moment(doc.installedOn).format('dddd, MMMM Do YYYY'),
                baseUrl,
                appBaseUrl,
                orgUnit: doc.orgUnit||'',
                imagesBaseUrl: baseUrl+'/images/page/asset-status',
                feedbackUrl: parentOrgUnit?.custom?.feedbackUrl
            };
            data.statusLastUpdatedOn= Moment(doc.custom?.currentUpdatedOn).format('MMMM Do YYYY');
            data.waitingPeriod= (maxWaitingWeeks === 0) ? '0 Weeks': (minWaitingWeeks + ' - '+ maxWaitingWeeks + ' Weeks');

            emailService.sendEJS(subject+' '+sku.model, emailTemplatePath, data, userEmail, from,function(err) {
                if(err){
                    console.log(`Error sending status update Email to ${userEmail} ${err}`);
                    triggerData.email.success= false;
                    triggerData.email.error= err;
                }
                else {
                    console.log(`Status update email sent to user ${userName} to ${userEmail}`);
                    triggerData.email.success= true;
                }
                next();
            });
        };

        const sendStatusUpdateSMS= (next)=>{
            if (!userMobile){
                return next();
            }
            let templateStrId;
            if (is2TriggerWelcome){
                templateStrId= 'assetMapping2Customer';
            }
            else {
                if (doc.status === 'delivered'){
                    //TODO: need to implement template
                    return  next();
                }
                else {
                    templateStrId= 'assetStatusUpdate';
                }
            }
            const template= parentOrgUnit.custom.smsTemplates.bookingStatusUpdate;
            const senderId= parentOrgUnit.custom.senderId;
            // const template= app.locals.Settings.sms.template[templateStrId];
            const data= {
                model: doc.extSku?.model||sku.model||'vehicle',
                title: customer.title,
                firstName: customer.name||customer.firstName,
                serialNumber: doc.serialNumber,
                appBaseUrl,
                orgUnitName: orgUnit?.name||'Toyota'
            };
            let model= data.model.trim().toUpperCase().replace('URBAN CRUISER', 'UC');
            data.arr= [
                customer.title+ ' '+(customer.name||customer.firstName),
                doc.serialNumber.replace(orgUnit.code, '')+ ' for '+model
            ];
            mainApp.locals.services.SMS.send(userMobile, template, data, (err)=>{
                if(err){
                    console.log(`Error sending status update SMS to ${userEmail} ${err}`);
                    triggerData.sms.success= false;
                    triggerData.sms.error= err;
                }
                else {
                    console.log(`Status update sms sent to user ${userName} to ${userEmail}`);
                    triggerData.sms.success= true;
                }
                next();
            }, {useSubAccount: true, config:{senderId, apiKey: parentOrgUnit.custom.apiKey}});
        };

        const updateStatusUpdateInfo= (next)=>{
            let triggerChannels= [];
            if (userEmail){
                triggerChannels.push('email');
            }
            if (userMobile){
                triggerChannels.push('sms');
            }
            let triggerStatus;
            let numSuccess= 0;
            let numChannels= triggerChannels.length;
            triggerChannels.forEach((channel)=>{
                if (!triggerData[channel].success){
                    numSuccess++;
                }
            });
            if (numChannels === 0){
                triggerStatus= 'noChannels';
            }
            else {
                if (numSuccess === 0){
                    triggerStatus = 'failure';
                }
                else if (numSuccess < numChannels) {
                    triggerStatus = 'partialSuccess';
                }
                else {
                    triggerStatus = 'success';
                }
            }

            doc.isLatestStatusUpdateTriggered= true;
            doc.lastStatusUpdateTriggeredOn= new Date();

            doc.lastStatusUpdateTriggerStatus= triggerStatus;

            doc.lastStatusUpdateTriggerChannels= triggerChannels;
            doc.markModified('lastStatusUpdateTriggerChannels');

            doc.lastStatusUpdateTriggerData= triggerData;
            doc.markModified('lastStatusUpdateTriggerData');
            if (is2TriggerWelcome){
                doc.isWelcomeTriggered= true;
            }

            let evt= {...EVENT.COMMUNICATION_SENT};
            let channelIds= [];
            if (userMobile){
                channelIds.push(MaskEmailsPhones(userMobile));
            }
            if (userEmail){
                channelIds.push(MaskEmailsPhones(userEmail));
            }
            evt.desc= `triggered ${is2TriggerWelcome? 'welcome communication':'booking update'} to ${channelIds.join(' and ')}`;
            let evtInstance= getEventInstance(by, evt, doc);
            evtInstance.save((err) => {
                doc.lastEvent= evtInstance;
                doc.markModified('lastEvent');
                doc.save((err)=>{
                    if (err){
                        return next({...K.ERROR.MONGO_SAVE, details: err});
                    }
                    return next();
                });
            });
        };

        const steps= [
            loadCustomer,
            loadSKU,
            loadOrgUnitInfo,
            sendStatusUpdateEmail,
            sendStatusUpdateSMS,
            updateStatusUpdateInfo
        ];
        Async.series(steps, (err)=>{
            if (err){
                console.log('error while sending status update!', err);
                return cb(err);
            }
            console.log('successfully sent status update!');
            return cb();
        });
    }

    schemaObj.virtual('publicUrl').get(function() {
        const orgSeqId = app.locals.id;
        let baseUrl;
        let appPrefix= 'app'
        if (Settings.asset.publicUrlVersion){
            appPrefix= 'appv2';
        }
        baseUrl = `${Settings.baseUrl}${appPrefix}/open/org`;
        return `${baseUrl}/${orgSeqId}/asset/${this.publicCode}`;
    });

    schemaObj.virtual('qrCodeUrl').get(function() {
        let orgSeqId= app.locals.id;
        let QRCodeFileName= this.seqId;
        if (Settings.asset.publicUrlVersion){
            const paddedSeqId= this.code.replace(SEQ_CODE_PREFIX, '');
            QRCodeFileName= paddedSeqId;
        }
        return `/data/org/${orgSeqId}/assets/qrcodes/${QRCodeFileName}.png`;
    });

    schemaObj.virtual('openUrl').get(function() {
        let orgSeqId= app.locals.id;
        return `${app.locals.credentials.baseUrl}app/open/org/${orgSeqId}/asset/${this.publicCode}`;
    });

    schemaObj.methods.reset2Draft= function () {
        let DRAFT_FIELDS= {
            "_id" : true,
            "ownershipType" : "customer_owned",
            "status" : "01_draft",
            "createdBy" : true,
            "createdOn" : true,
            "lastModifiedOn" : true,
            "code" : true,
            "seqId" : true,
            "publicCode" : true,
            "name" : "Draft Asset",
            "lastModifiedBy" : true,
            '__v': true
        }
        for (let key in schemaObj.paths) {
            if (!DRAFT_FIELDS[key]){
                this.set(key, undefined);
            }
        }
        this.status= '01_draft';
        this.name= 'Draft Asset '+ this.seqId;
    }

    schemaObj.methods.getShortForm = function () {
        let ret= {
            _id : this._id,
            name: this.name,
            code: this.code,

            secondaryCode: this.secondaryCode,
            serialNumber: this.serialNumber,
            secondarySerialNumber: this.secondarySerialNumber,
            extraCode1: this.extraCode1,
            extraCode2: this.extraCode2,

            contact: this.contact,
            locatedAt: this.locatedAt,

            isUnderWarranty: this.isUnderWarranty,

            purchaseCost: this.purchaseCost,
            serviceProvidedBy: this.serviceProvidedBy,
            isCritical: this.isCritical
        };
        if (this.model){
            ret.model= {...this.model};
        }
        if (this.contract){
            ret.contract= {
                _id: this.contract._id,
                name: this.contract.name,
                code: this.contract.code
            }
        }
        return ret;
    };

    schemaObj.methods.attachContract = function (by, contract, cb) {
        this.contract = contract.getShortForm();
        this.markModified('contract');
        this.save(cb);
        //TODO: need to add entry into the event log
    };

    schemaObj.methods.attachContractAsync = async function (by, contract) {
        this.contract = contract.getShortForm();
        this.markModified('contract');
        await this.save();
        //TODO: need to add entry into the event log
    };

    schemaObj.methods.detachContract = function (by, data, cb) {
        this.contract = undefined;
        this.markModified('contract');
        const Ticket= app.locals.models.Ticket;
        Ticket.deleteMany({sType:'pm', 'asset._id': this._id, status:{$nin:['05_closed', '06_cancelled', '05_cancelled']}}, (err)=>{
            if (err){
                return cb(err);
            }
            return this.save(cb);
        });
        //TODO: need to add entry into the event log
    };

    schemaObj.methods.detachContractAsync = async function (by) {
        this.contract = undefined;
        this.lastModifiedBy= by;
        this.markModified('contract');
        const Ticket= app.locals.models.Ticket;
        await Ticket.deleteMany({sType:'pm', 'asset._id': this._id, status:{$nin:['05_closed', '06_cancelled', '05_cancelled']}});
        await this.save();
        //TODO: need to add entry into the event log
    };

    schemaObj.methods.noteMeterReadings = function(by, readings, tkt, dt, cb) {
        console.log('noting ')
        let asOn = dt? Moment(dt).toDate(): new Date();
        let meterReadings = {
            asOn
        };
        let readingsMap={};
        Lodash.map(readings,(r)=>{
            readingsMap[r.id||r._id.toString()]= Number(r.reading);
            return;
        });
        meterReadings.readings = readingsMap;
        if (tkt){
            meterReadings.ticket = tkt.getShortForm();
        }
        if (this.latestMeterReadings && this.latestMeterReadings.asOn){
            if (!this.pastMeterReadings){
                this.pastMeterReadings= [];
            }
            this.pastMeterReadings.push({...this.latestMeterReadings});
            this.markModified('pastMeterReadings');
        }
        this.latestMeterReadings = meterReadings;
        this.markModified('latestMeterReadings');
        //TODO: add event log
        return cb && cb();
    };

    function getEventInstance(by, event, asset) {
        const Event = app.locals.models.EventLog;
        let evt = new Event({
            evtType: event.code,
            desc : event.desc||event.name,
            doneBy: {
                _id: by._id||by.id,
                name: by.name,
                code: by.code
            },
            scope:{
                sType:'asset',
                _id: asset._id,
                code: asset.serialNumber|| asset.secondaryCode || asset.code
            },
            createdBy: by._id||by.id,
            when: new Date()
        });
        return evt;
    }

    schemaObj.methods.updateFieldGroup = function(by, data, cb) {
        //TODO: need to check if we can generalize individual functions to update group of fields
    };

    schemaObj.methods.updateBasicDetails = function (by, data, cb) {
        const updateCodes= (next) =>{
            for (let key in data){
                this[key]= data[key];
            }
            return next();
        };

        const updateProductModel = (next) =>{
            if (!data.modelId || (this.model &&this.model._id && (data.modelId === this.model._id.toString()))){ //No change in model
                return next();
            }
            const ProductModel = app.locals.models.ProductModel;
            const Product= app.locals.models.Product;
            ProductModel.findById(data.modelId, (err, productModel)=>{
                if (err){
                    return  next(err);
                }
                if (!productModel){
                    return next({message:'product model not found!'});
                }
                Product.findById(productModel.product._id, (err, product)=>{
                    if(err){
                        return next(err);
                    }
                    if (!product){
                        return next({message:'product not found!'});
                    }
                    this.model= productModel.getShortForm();
                    this.model.product= product.getShortForm();
                    return next();
                });
            });
        };

        const addEventLog= (next) => {
            let evt = getEventInstance(by, EVENT.UPDATE_BASIC_DETAILS, this);
            evt.save((err) => {
                if (err) {
                    return next(err);
                }
                this.lastEvent = evt;
                this.markModified('lastEvent');
                return next();
            });
        };

        Async.series([updateCodes, updateProductModel, addEventLog], (err) =>{
            if (err){
                return cb(err);
            }
            this.save((err)=>{
                cb(err, this);
            });
        });
    };

    schemaObj.methods.updateStatus = function(by,data,cb){
        this.status = data.status;
        this.remarks = data.remarks;
        
        const addEventLog= (next) => {
            let evt = getEventInstance(by, EVENT.UPDATE_STATUS, this);
            evt.save((err) => {
                if(err) return next(err);
                this.lastEvent = evt;
                this.markModified('lastEvent');
                return next();
            });
        };

        Async.series([
            addEventLog
        ],(err) =>{
            if(err) return cb(err);
            this.save(err => cb(err,this));
        });
    };

    schemaObj.methods.updateAddress = function (by, data, cb) {
        this.isAddrSameAsCustomerAddr= false;
        this.address= data.address;
        this.markModified('address');
        this.locatedAt= data.locatedAt;
        let evt = getEventInstance(by, EVENT.UPDATE_ADDRESS, this);
        evt.save((err)=>{
            if (err){
                return cb(err);
            }
            this.lastEvent= evt;
            this.markModified('lastEvent');
            this.save((err)=>{
                cb(err, this);
            });
        });
    };

    schemaObj.methods.updateCustomer = function (by, data, cb) {
        const Customer = app.locals.models.Customer;
        const customerId= data.id;
        const prevCustomerId = this.customer ? this.customer._id: undefined;

        const setNewCustomerDetails = (next) =>{
            Customer.findById(customerId, (err, customer)=>{
                if (err){
                    return next(err);
                }
                if (!customer){
                    return next(`Customer ${customerId} not found`);
                }
                this.customer= customer.getShortForm();
                this.contact = customer.contact;
                this.markModified('customer');
                if (this.isAddrSameAsCustomerAddr !== false){
                    if (!Settings.site || !Settings.site.isEnabled){
                        this.address= {...customer.address};
                        this.markModified('address');
                    }
                }
                this.lastModifiedBy= by._id||by.id;
                return next();
            });
        };

        const addEventLog = (next) =>{
            let evt = getEventInstance(by, EVENT.UPDATE_CUSTOMER, this);
            evt.save((err)=>{
                if (err){
                    return next(err);
                }
                this.lastEvent= evt;
                this.markModified('lastEvent');
                next();
            });
        };

        const doSave= (next) =>{
            this.save(next);
        };

        const updatePrevCustomerStats = (next) =>{
            if (!prevCustomerId) {
                return next();
            }
            Customer.findById(prevCustomerId, (err, customer) => {
                if (err){
                    return next(err);
                }
                if (!customer) {
                    return next({message:`Customer ${prevCustomerId} not found  for asset ${ this._id}!`});
                }
                Asset.count({'customer._id': prevCustomerId}, (err, count)=>{
                    if (err){
                        return next(err);
                    }
                    customer.numAssets = count;
                    customer.save(next);
                });
            });
        };
        Async.series([
            setNewCustomerDetails,
            addEventLog,
            doSave,
            updatePrevCustomerStats
        ], (err)=>{cb(err, this)});
    };

    schemaObj.methods.updateTechnician = function (by, data, cb) {
        const OrgUser= app.locals.models.OrgUser;
        const techId= data.id;
        if (!techId) {
            this.technician= undefined;
            this.markModified('technician');
            this.save((err)=>{
                return cb(err, this);
            });
            return;
        }
        OrgUser.findById(techId, (err, technician)=>{
            if (err){
                return cb(err);
            }
            if (!technician){
                return cb(`Technician ${techId} not found !`);
            }
            this.technician= technician.getShortForm();
            this.markModified('technician');
            let evt = getEventInstance(by, EVENT.UPDATE_TECHNICIAN, this);
            evt.save((err)=>{
                if (err){
                    return cb(err);
                }
                this.lastEvent= evt;
                this.markModified('lastEvent');
                this.save((err)=>{
                    cb(err, this);
                });
            });
        });
    };

    schemaObj.methods.updateOrgUnit = function(by,data,cb){
        const OrgUnit = app.locals.models.OrgUnit;
        OrgUnit.findById(data.id, (err,result) => {
            if(err) return cb(err);
            if(!result) return cb(`Org Unit ${data.id} not found`);
            this.orgUnit = result.getShortForm();
            this.orgUnit.custom= result.custom;
            this.markModified('orgUnit');
            const event = getEventInstance(by,EVENT.UPDATE_ORG_UNIT,this);
            event.save(err => {
                if(err) return cb(err);
                this.lastEvent = event;
                this.markModified('lastEvent');
                this.save(err => cb(err,this));
            });
        });
    };

    schemaObj.methods.updateSite = function(by,data,cb){
        const Site = app.locals.models.Site;
        Site.findById(data.id, (err,result) => {
            if(err) return cb(err);
            if(!result) return cb(`Site ${data.id} not found`);
            this.site = result.getShortForm();
            this.markModified('site');
            this.address= {...result.address};
            this.markModified('address');
            const event = getEventInstance(by,EVENT.UPDATE_SITE,this);
            event.save(err => {
                if(err) return cb(err);
                this.lastEvent = event;
                this.markModified('lastEvent');
                this.save(err => cb(err,this));
            });
        });
    };

    schemaObj.methods.updateAccessories = function(by,data,cb){
        const Accessory = app.locals.models.Accessory;
        let accessoriesInstalled= [];
        let accessoryInputInfoMap= {};
        let accessoryIds = Lodash.map(data.accessoriesInstalled, (val)=>{
            if(val.installedOn){
                val.installedOn= Moment(val.installedOn, 'YYYY-MM-DD').toDate();
            }
            accessoryInputInfoMap[val.id]= val;
            return Mongoose.Types.ObjectId(val.id);
        });
        //TODO: add event log
        Accessory.find({_id:{$in:accessoryIds}}, (err, accessories)=> {
            if (err) {
                return cb(err);
            }
            Lodash.map(accessories, (accessory) => {
                accessoriesInstalled.push({
                    ... accessoryInputInfoMap[accessory._id.toString()],
                    ...accessory.getShortForm()
                });
            });
            this.accessoriesInstalled= [ ...accessoriesInstalled];
            this.markModified('accessoriesInstalled');
            this.save((err)=>{
               cb(err, this);
            });
        });
    };

    schemaObj.methods.updateContact = function (by, data, cb) {
        this.contact= data.contact;
        this.markModified('contact');
        let evt = getEventInstance(by, EVENT.UPDATE_CONTACT_DETAILS, this);
        evt.save((err)=>{
            if (err){
                return cb(err);
            }
            this.lastEvent= evt;
            this.markModified('lastEvent');
            this.save((err)=>{
                cb(err, this);
            });
        });
    };


    //Static functions on the model

    schemaObj.statics.sync = function(coll, dupRecord, cb) {
        let cond= {}, updateValues= {};
        if (coll === 'customer') {
            cond['customer._id']= dupRecord._id;
            updateValues= {
                customer: {...dupRecord.getShortForm()}
            };
            this.updateMany(cond, {$set:updateValues}, {}, cb);
        }
        else if(coll=== 'model'){
            cond['model._id']= dupRecord._id;
            this.find(cond, {}, (err, records)=>{
                if(err){
                    return cb();
                }
                if (records.length === 0){
                    return cb();
                }
                const updateRecord= (record, next)=>{
                    record.model= dupRecord.getShortForm();
                    record.markModified('model');
                    record.save(next);
                };
                Async.eachSeries(records, updateRecord, cb);
            });
        }
        //FIXME: add product and model update sync as well
        //NOTE: Don't do update on each of the record, as that will trigger infinite loop, with post save called
    };

    schemaObj.statics.updateBasicDetails = function(by, id, data, cb) {
        this.findById(id, (err, asset)=>{
            if (err) {
                return cb(err);
            }
            asset.updateBasicDetails(by, data, cb);
        });
    };

    schemaObj.statics.updateStatus = function(by,id,data,cb) {
        this.findById(id,(err,asset)=>{
            if(err) return cb(err);
            asset.updateStatus(by,data,cb);
        });
    };

    schemaObj.statics.updateAddress = function(by, id, data, cb) {
        this.findById(id, (err, asset)=>{
            if (err) {
                return cb(err);
            }
            asset.updateAddress(by, data, cb);
        });
    };

    schemaObj.statics.updateCustomer = function(by, id, data, cb) {
        this.findById(id, (err, asset)=>{
            if (err) {
                return cb(err);
            }
            asset.updateCustomer(by, data, cb);
        });
    };

    schemaObj.statics.updateTechnician = function(by, id, data, cb) {
        this.findById(id, (err, asset)=>{
            if (err) {
                return cb(err);
            }
            asset.updateTechnician(by, data, cb);
        });
    };

    schemaObj.statics.updateOrgUnit = function(by,id,data,cb){
        this.findById(id, (err,asset) => {
            if(err) return cb(err);
            asset.updateOrgUnit(by,data,cb);
        });
    };

    schemaObj.statics.updateSite = function(by,id,data,cb){
        this.findById(id, (err,asset) => {
            if(err) return cb(err);
            asset.updateSite(by,data,cb);
        });
    };

    schemaObj.statics.updateContact = function(by, id, data, cb) {
        this.findById(id, (err, asset)=>{
            if (err) {
                return cb(err);
            }
            asset.updateContact(by, data, cb);
        });
    };

    schemaObj.statics.sendStatusUpdate2Customer = function(by, id, data, cb) {
        this.findById(id, (err, asset)=>{
            if (err) {
                return cb(err);
            }
            asset.sendStatusUpdate2Customer(by, data, (err)=>{
                return cb(err, asset);
            });
        });
    };

    schemaObj.statics.findByPublicCode = function (publicCode, cb){
        this.findOne({publicCode: publicCode})
            .then((doc) => {
                if (!doc) {
                    return cb({message: 'Asset not found'});
                }
                return cb(undefined, doc);
            })
            .catch((err) => {
                cb(err);
            });
    };

    schemaObj.statics.getEvents = function(id, cb){
        const EventLog= app.locals.models.EventLog;
        EventLog.find({'scope._id': Mongoose.Types.ObjectId(id)}, cb);
    };

    schemaObj.statics.getServiceHistory = function(id, cb){
        const Ticket = app.locals.models.Ticket;
        let assetId= Mongoose.Types.ObjectId(id);
        let asset;
        let tickets = [];
        const loadAsset = (next)=>{
            this.findById(assetId)
                .then((doc) => {
                    asset = doc.toObject();
                    return next();
                })
                .catch((err) => {
                    return next(err);
                });
        };
        const loadTickets = (next)=>{
            let cond = {
                'asset._id': assetId
            };
            if (asset.contract){
                cond['contract._id']= asset.contract._id;
            }
            Ticket.find(cond, (err, docs)=>{
                if (err){
                    return next(err);
                }
                tickets=[];
                docs.forEach((doc)=>{
                    tickets.push(doc.toObject());
                })
                return next();
            });
        };

        const steps= [
            loadAsset,
            loadTickets
        ];
        Async.series(steps, (err)=>{
            if (err){
                return cb(err);
            }
            cb(undefined, tickets);
        });
    };

    schemaObj.statics.getContracts = function(id, cb){
        const Contract = app.locals.models.Contract;
        let assetId= Mongoose.Types.ObjectId(id);
        let asset;

        const loadAsset = (next)=>{
            this.findById(assetId)
                .then((doc) => {
                    asset = doc.toObject();
                    return next();
                })
                .catch((err) => {
                    return next(err);
                });
        };
        const loadContracts = (next)=>{
            let cond = {
                'asset._id': assetId
            };
            if (asset.contract){
                cond['contract._id']= asset.contract._id;
            }
            Contract.find(cond, (err, docs)=>{
                if (err){
                    return next(err);
                }
                asset.tickets=[];
                docs.forEach((doc)=>{
                    asset.tickets.push(doc.toObject());
                })
                return next();
            });
        };

        const steps= [
            loadAsset,
            loadContracts
        ];
        Async.series(steps, cb);
    };

    schemaObj.statics.getDetails = function(id, cb) {
        const Ticket = app.locals.models.Ticket;
        let assetId= Mongoose.Types.ObjectId(id);
        let asset;
        const loadAsset = (next)=>{
            this.findById(assetId)
                .then((doc) => {
                    asset = doc.toObject();
                    return next();
                })
                .catch((err) => {
                    return next(err);
                });
        };

        const loadPMTickets = (next) =>{
            let cond = {
                'asset._id': assetId,
                sType: 'pm'
            };
            if (asset.contract){
                cond['contract._id']= asset.contract._id;
            }
            Ticket.find(cond, (err, docs)=>{
                if (err){
                    return next(err);
                }
                asset.pmTkts=[];
                docs.forEach((doc)=>{
                    asset.pmTkts.push(doc.toObject());
                });
                return next();
            });
        };

        const loadOpenNonPMTickets = (next)=>{
            let cond = {
                'asset._id': assetId,
                sType: {$ne:'pm'},
                status: {$ne:'closed'}
            };
            if (asset.contract){
                cond['contract._id']= asset.contract._id;
            }
            Ticket.find(cond, (err, docs)=>{
                if (err){
                    return next(err);
                }
                asset.nonPMTkts=[];
                docs.forEach((doc)=>{
                    asset.nonPMTkts.push(doc.toObject());
                })
                return next();
            });
        };

        const steps= [
            loadAsset,
            loadPMTickets,
            loadOpenNonPMTickets
        ];
        Async.series(steps, ()=>{
            cb(undefined, asset);
        });
    };

    schemaObj.statics.doUpdate = function (by, id, data, cb) {
        this.findById(id, (err, doc) => {
            if (err) {
                return cb({...K.ERROR.MONGO_FIND, details: err});
            }
            if (!doc) {
                return cb({...K.ERROR.DOC_NOT_FOUND});
            }
            const accessoriesInstalled = data.accessoriesInstalled;
            if (accessoriesInstalled){
                for (let i=0; i<accessoriesInstalled.length; i++){
                    let acc= accessoriesInstalled[i];
                    acc._id= Mongoose.Types.ObjectId(acc._id||acc.id);
                    acc.createdBy= by;
                }
            }
            for (let key in data) {
                if(key === 'custom'){
                    if (CollectionSettings.trackStatusUpdate){   //tkm specific
                        const curr2Prev= {
                            "currentBookingSequenceNumber": 'prevBookingSequenceNumber',
                            "currentMinWaitingPeriodInWeeks": 'prevMinWaitingPeriodInWeeks',
                            "currentMaxWaitingPeriodInWeeks": 'prevMaxWaitingPeriodInWeeks',
                            "currentWaitingPeriodInWeeks": "prevWaitingPeriodInWeeks",
                            "currentUpdatedOn": "prevUpdatedOn"
                        };
                        data.custom.currentUpdatedOn= new Date();
                        if (typeof doc.custom?.prevBookingSequenceNumber !== 'undefined'){
                            let prevUpdates= doc.custom.prevUpdates||[];
                            let prevUpdateObj= {};
                            for (let currKey in curr2Prev){
                                prevUpdateObj[curr2Prev[currKey]]= doc.custom[curr2Prev[currKey]];
                            }
                            prevUpdates.push(prevUpdateObj);
                            data.custom.prevUpdates= prevUpdates;
                        }
                        if (typeof doc.custom?.currentBookingSequenceNumber !== 'undefined'){
                            for (let currKey in curr2Prev){
                                data.custom[curr2Prev[currKey]]= doc.custom[currKey];
                            }
                        }
                        doc.isLatestStatusUpdateTriggered= false;
                        if (data.custom?.tentativeDeliveryQuoted){
                            data.custom.tentativeDeliveryQuotedFmt= toDate(data.custom.tentativeDeliveryQuoted, 'DD MMM YY') ||'';
                        }
                    }
                    data.custom= {...doc.custom, ...data.custom};
                }
                doc.set(key, data[key]);
                doc.markModified(key);
            }
            let evt;
            if (CollectionSettings.trackStatusUpdate) {   //tkm specific
                evt = {...EVENT.UPDATE_BOOKING_STATUS};
                let prevBookingSequenceNumber = doc.custom.prevBookingSequenceNumber || doc.custom.initialBookingSequenceNumber;
                let prevWaitingPeriod = doc.custom?.prevWaitingPeriodInWeeks || doc.custom.waitingPeriodInWeeksQuoted;
                evt.desc = `updated Sequence Number from ${prevBookingSequenceNumber} to ${doc.custom.currentBookingSequenceNumber}. `;
                evt.desc += `updated Waiting period from ${prevWaitingPeriod} to ${doc.custom.currentWaitingPeriodInWeeks}`;
            }
            else {
                evt= {...EVENT.UPDATE_PRIMARY_DETAILS};
            }
            let evtInstance = getEventInstance(by, evt, doc);
            evtInstance.save((err) => {
                doc.lastEvent = evtInstance;
                doc.markModified('lastEvent');
                doc.save((err) => {
                    if (err) {
                        return cb({...K.ERROR.MONGO_SAVE, details: err});
                    }
                    return cb(undefined, doc);
                });
            });
        });
    };

    schemaObj.statics.updateAccessories= function(by, id, data, cb) {
        this.findById(id, (err, doc) => {
            if (err) {
                return cb({...K.ERROR.MONGO_FIND, details: err});
            }
            if (!doc) {
                return cb({...K.ERROR.DOC_NOT_FOUND});
            }
            doc.updateAccessories(by, data, cb);
        });
    }

    schemaObj.statics.logPDCheckList= function(by, id, data, cb) {
        const Ticket= app.locals.models.Ticket;
        const Asset= this;

        let pdNumber= 0;
        let pdTicket;
        let asset;

        const loadAsset= (next) =>{
            let cond= {};
            if (Mongoose.isValidObjectId(id)){
                cond= {_id: Mongoose.Types.ObjectId(id)};
            }
            else {
                cond= {seqId: Number(id)};
            }
            Asset.findOne(cond, (err, record)=>{
                if(err){
                    return next(err);
                }
                asset= record;
                return next();
            });
        };

        const countNumPdsDone=(next)=>{
            Ticket.count({'asset._id': asset._id}, (err, count)=>{
                if (err){
                    return next(err);
                }
                pdNumber= count;
                return next();
            });
        };

        const createPDTicket= (next)=>{
            pdNumber++;
            const ticketData = {
                sType: 'pd',
                name: 'PD ' + pdNumber,
                asset,
                customerId: asset.customer?._id,
                source: 'system_generated'
            };
            Ticket.create(by, ticketData, (err, tkt)=>{
                pdTicket= tkt;
                next(err);
            }, true);

        }

        const closePDTicket= (next)=>{
            Ticket.closeV2(by, pdTicket._id, data, next);
        }

        const steps= [
            loadAsset,
            countNumPdsDone,
            createPDTicket,
            closePDTicket
        ];

        Async.series(steps, (err)=>{
            if (err){
                return cb(err);
            }
            return cb();
        });
    };
    /**
     * https://qristix.com/app/open/org/{org sequence id}/asset/{random 8 unique code for org}-{8 hex seq 00000001} - {random 8 char alphanumeric}
     */
    schemaObj.statics.generateBulk = function (count, options={}, cb) {
        const AssetModel = this;
        let orgUnit;
        const loadOrgUnit= (next)=>{
            const OrgUnit= app.locals.models.OrgUnit;
            if (!options?.orgUnitId){
                return next();
            }
            OrgUnit.findById(options.orgUnitId, (err, record)=>{
                if (err){
                    return next(err);
                }
                if (!record){
                    return next('org unit not found');
                }
                orgUnit= record;
                return  next();
            });
        };

        const doCreateAssets= (next)=> {
            const createAsset = (index, next2) => {
                let asset = new AssetModel({createdBy: app.locals.admin._id});
                if (orgUnit){
                    asset.orgUnit= orgUnit.getShortForm();
                    asset.orgUnit.custom= {...orgUnit.custom}
                }
                asset.save(next2);
            };
            Async.timesSeries(count, createAsset, next);
        }
        Async.series([
                loadOrgUnit,
                doCreateAssets,
            ],
            cb
        );
    };

    schemaObj.statics.generateQRCodeStickers = function (options, cb) {
        const AssetModel = this;

        const orgSeqId = app.locals.id;
        const qrcodesOutDir = app.locals.dirs.qrcodes;
        let condition= {};
        let assetSeqIdStart = 1;
        let assetSeqIdEnd = assetSeqIdStart;
        let fileName= '';
        let assets= [];
        let htmlOutput= '';

        const loadMetaInfo = (next) =>{
            if (!options) {
                return next();
            }

            if (options.orgUnitCode) {
                condition['orgUnit.code'] = options.orgUnitCode;
                fileName= options.orgUnitCode;
            }
            else if (options.customerCode) {
                condition['customer.code'] = options.customerCode;
                fileName= options.customerCode;
            }
            else if (options.siteCode) {
                condition['site.code'] = options.siteCode;
                fileName= options.siteCode;
            }
            else if(options.status){
                condition.status= options.status;
            }
            else if (options.seqId){
                condition.seqId= {$in: options.seqId};
            }
            else {
                if (options.seqIdStart) {
                    condition.seqId = {$gte: options.seqIdStart};
                    assetSeqIdStart = options.seqIdStart;
                    assetSeqIdEnd = assetSeqIdStart;
                }
                if (options.seqIdEnd) {
                    if (!condition.seqId) {
                        condition.seqId = {};
                    }
                    condition.seqId['$lte'] = options.seqIdEnd;
                    assetSeqIdEnd = options.seqIdEnd;
                }
            }
            return next();
        };

        const loadAssets = (next) =>{
            const fields= {seqId:1, code:1, secondaryCode:1, serialNumber:1};
            AssetModel.find(condition,fields,{sort:{seqId:1}}, (err, records) =>{
                if(err){
                    return next(err);
                }
                assets= records;
                let numQrCodes = assets.length;
                if (assetSeqIdEnd === assetSeqIdStart){
                    assetSeqIdEnd= assetSeqIdStart+numQrCodes-1;
                }
                if (!fileName) {
                    fileName= `${assetSeqIdStart}-${assetSeqIdEnd}`;
                }
                console.log('num Assets:', numQrCodes, fileName);
                return next();
            });
        };

        const generateHtml = (next) =>{
            let htmlFile = `${qrcodesOutDir}/${fileName}.html`;
            let data = {...app.locals.Settings};
            let options = {};
            let outAssets= [];

            for (let index=0; index<assets.length; index++){
                let record= assets[index];
                outAssets[index]= {
                    qrCodeImageUrl: record.qrCodeUrl,
                    code    : record.code,
                    primaryIdentifier: Settings.qrSticker.includePrimaryIdentifier? record[Settings.asset.primaryIdentifier]: ''
                };
            }
            data.assets = outAssets;
            data.baseUrl = app.locals.credentials.baseUrl;
            data.baseUrl= data.baseUrl.substr(0,data.baseUrl.length-1);
            data.fileName= fileName;

            const templateName= app.locals.Settings.qrSticker.template;
            EJS.renderFile(`tpls/html/${templateName}.ejs`, data, options, (err, tplOutput)=>{
                if(err){
                    console.log('error creating html', err);
                    return next(err);
                }
                htmlOutput= tplOutput;
                console.log('success!', htmlFile);
                FS.writeFile(htmlFile, htmlOutput, 'utf8', next);
            });
        };

        const generatePdf = (next) =>{
            let pdfFile = `${qrcodesOutDir}/${fileName}.pdf`;
            let file = { content: htmlOutput };
            let options = { width: '12in', height: '18in', path: pdfFile };
            html_to_pdf.generatePdf(file, options)
                .then(() => {
                    return next();
                })
                .catch((err)=>{
                    return next(err);
                });
        };

        Async.series([loadMetaInfo, loadAssets, generateHtml, generatePdf], cb);
    };

    const Asset = Db.model(COLLECTION_NAME, schemaObj);
    app.locals.models.Asset = Asset;

    const Counter = app.locals.models.Counter;
    const sysUser = app.locals.sysUser;

    Counter.initCounter(sysUser._id, COLLECTION_NAME, 0, {prefix:SEQ_CODE_PREFIX, padding:SEQ_ID_PADDING}, (err)=>{
        Asset.syncIndexes();
        return doneCb(err);
    });
};
